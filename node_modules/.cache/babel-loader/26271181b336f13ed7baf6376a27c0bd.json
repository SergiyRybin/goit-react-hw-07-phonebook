{"ast":null,"code":"\"use strict\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPersistConfig = exports.getTransforms = exports.createBlacklist = exports.createWhitelist = exports.autoMergeDeep = void 0;\n\nconst utils_1 = require(\"./utils\");\n\nconst constants_1 = require(\"./constants\");\n\nconst types_1 = require(\"./types\");\n\nconst createTransform = function (inbound, outbound) {\n  let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const whitelist = config.whitelist || null;\n  const blacklist = config.blacklist || null;\n\n  function whitelistBlacklistCheck(key) {\n    if (whitelist && whitelist.indexOf(key) === -1) return true;\n    if (blacklist && blacklist.indexOf(key) !== -1) return true;\n    return false;\n  }\n\n  return {\n    in: (state, key, fullState) => !whitelistBlacklistCheck(key) && inbound ? inbound(state, key, fullState) : state,\n    out: (state, key, fullState) => !whitelistBlacklistCheck(key) && outbound ? outbound(state, key, fullState) : state,\n    deepPersistKey: whitelist && whitelist[0]\n  };\n};\n\nconst autoMergeDeep = (inboundState, originalState, reducedState, _ref) => {\n  let {\n    debug,\n    whitelist,\n    blacklist,\n    transforms\n  } = _ref;\n\n  if (whitelist || blacklist) {\n    throw new Error('State reconciler autoMergeDeep uses custom transforms instead of old whitelist or blacklist config properties. Please use createWhitelist or createBlacklist transforms.');\n  }\n\n  (0, utils_1.transformsValidator)(transforms);\n  const newState = (0, utils_1.cloneDeep)(reducedState);\n  let toRehydrateState = inboundState;\n\n  if (toRehydrateState && (0, utils_1.isObjectLike)(toRehydrateState)) {\n    const diff = (0, utils_1.difference)(originalState, reducedState);\n\n    if (!(0, utils_1.isEmpty)(diff)) {\n      toRehydrateState = (0, utils_1.mergeDeep)(inboundState, diff, {\n        preserveUndefined: true\n      });\n\n      if (debug) {\n        console.log(`${constants_1.PACKAGE_NAME}/autoMergeDeep: sub state of your state was modified by reducer during rehydration. Values from reducer will be kept: ${JSON.stringify(diff)}`);\n      }\n    }\n\n    Object.keys(toRehydrateState).forEach(key => {\n      if (key === '_persist') {\n        return;\n      }\n\n      if ((0, utils_1.isObjectLike)(newState[key])) {\n        newState[key] = (0, utils_1.mergeDeep)(newState[key], toRehydrateState[key]);\n        return;\n      }\n\n      newState[key] = toRehydrateState[key];\n    });\n  }\n\n  if (debug && toRehydrateState && (0, utils_1.isObjectLike)(toRehydrateState)) {\n    console.log(`${constants_1.PACKAGE_NAME}/autoMergeDeep: rehydrated keys ${JSON.stringify(toRehydrateState)}`);\n  }\n\n  return newState;\n};\n\nexports.autoMergeDeep = autoMergeDeep;\n\nconst createWhitelist = (key, whitelist) => {\n  (0, utils_1.singleTransformValidator)(whitelist, key, types_1.ConfigType.WHITELIST);\n  return createTransform(inboundState => {\n    if (!whitelist || !whitelist.length) {\n      return inboundState;\n    }\n\n    let inboundToPersist = null;\n    let value;\n    whitelist.forEach(statePath => {\n      const pathArray = statePath.split('.');\n      value = (0, utils_1.path)(inboundState, pathArray);\n\n      if (typeof value === 'undefined' && (0, utils_1.isIntegerString)(pathArray[pathArray.length - 1])) {\n        value = constants_1.PLACEHOLDER_UNDEFINED;\n      }\n\n      const assocResult = (0, utils_1.assocPath)(pathArray, value);\n      const initial = (0, utils_1.isArray)(assocResult) ? [] : {};\n      inboundToPersist = (0, utils_1.mergeDeep)(!inboundToPersist ? initial : inboundToPersist, assocResult, {\n        preservePlaceholder: true\n      });\n    });\n    return inboundToPersist || inboundState;\n  }, outboundState => {\n    return (0, utils_1.preserveUndefined)(outboundState, whitelist, types_1.ConfigType.WHITELIST);\n  }, {\n    whitelist: [key]\n  });\n};\n\nexports.createWhitelist = createWhitelist;\n\nconst createBlacklist = (key, blacklist) => {\n  (0, utils_1.singleTransformValidator)(blacklist, key, types_1.ConfigType.BLACKLIST);\n  return createTransform(inboundState => {\n    if (!blacklist || !blacklist.length) {\n      return;\n    }\n\n    const inboundToPersist = (0, utils_1.preserveUndefined)(inboundState, blacklist, types_1.ConfigType.BLACKLIST, true);\n    const paths = blacklist.map(statePath => statePath.split('.'));\n    return paths.reduce((inboundToPersist, pathArray) => {\n      return (0, utils_1.dissocPath)(inboundToPersist, pathArray);\n    }, inboundToPersist);\n  }, outboundState => {\n    return (0, utils_1.preserveUndefined)(outboundState, blacklist, types_1.ConfigType.BLACKLIST);\n  }, {\n    whitelist: [key]\n  });\n};\n\nexports.createBlacklist = createBlacklist;\n\nconst getTransforms = function (type, list) {\n  return list.map(rootObject => {\n    const key = Object.keys(rootObject)[0];\n    const paths = rootObject[key];\n    return type === types_1.ConfigType.WHITELIST ? (0, exports.createWhitelist)(key, paths) : (0, exports.createBlacklist)(key, paths);\n  });\n};\n\nexports.getTransforms = getTransforms;\n\nconst getPersistConfig = _a => {\n  var {\n    key,\n    whitelist,\n    blacklist,\n    storage,\n    transforms,\n    rootReducer\n  } = _a,\n      rest = __rest(_a, [\"key\", \"whitelist\", \"blacklist\", \"storage\", \"transforms\", \"rootReducer\"]);\n\n  (0, utils_1.configValidator)({\n    whitelist,\n    blacklist\n  });\n  const whitelistByRootKeys = (0, utils_1.getRootKeysGroup)(whitelist);\n  const blacklistByRootKeys = (0, utils_1.getRootKeysGroup)(blacklist);\n  const allRootKeys = Object.keys(rootReducer(undefined, {\n    type: ''\n  }));\n  const whitelistRootKeys = whitelistByRootKeys.map(rootObject => Object.keys(rootObject)[0]);\n  const blacklistRootKeys = blacklistByRootKeys.map(rootObject => Object.keys(rootObject)[0]);\n  const keysToExclude = allRootKeys.filter(k => whitelistRootKeys.indexOf(k) === -1 && blacklistRootKeys.indexOf(k) === -1);\n  const whitelistTransforms = (0, exports.getTransforms)(types_1.ConfigType.WHITELIST, whitelistByRootKeys);\n  const blacklistTransforms = (0, exports.getTransforms)(types_1.ConfigType.BLACKLIST, blacklistByRootKeys);\n  const excludedKeysTransforms = (0, utils_1.isArray)(whitelist) ? keysToExclude.map(key => (0, exports.createBlacklist)(key)) : [];\n  return Object.assign(Object.assign({}, rest), {\n    key,\n    storage,\n    transforms: [...whitelistTransforms, ...blacklistTransforms, ...excludedKeysTransforms, ...(transforms ? transforms : [])],\n    stateReconciler: exports.autoMergeDeep\n  });\n};\n\nexports.getPersistConfig = getPersistConfig;","map":{"version":3,"mappings":"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","names":["createTransform","inbound","outbound","config","whitelist","blacklist","whitelistBlacklistCheck","key","indexOf","in","state","fullState","out","deepPersistKey","autoMergeDeep","inboundState","originalState","reducedState","debug","transforms","Error","newState","toRehydrateState","diff","preserveUndefined","console","log","constants_1","JSON","stringify","Object","keys","forEach","exports","createWhitelist","types_1","WHITELIST","length","inboundToPersist","value","statePath","pathArray","split","assocResult","initial","preservePlaceholder","outboundState","createBlacklist","BLACKLIST","paths","map","reduce","getTransforms","type","list","rootObject","getPersistConfig","_a","storage","rootReducer","rest","whitelistByRootKeys","blacklistByRootKeys","allRootKeys","undefined","whitelistRootKeys","blacklistRootKeys","keysToExclude","filter","k","whitelistTransforms","blacklistTransforms","excludedKeysTransforms","stateReconciler"],"sources":["/Users/sergiyrybin/Documents/IT/goit-react-hw-07-phonebook/node_modules/redux-deep-persist/src/index.ts"],"sourcesContent":["import {\n    isEmpty,\n    isArray,\n    isObjectLike,\n    isIntegerString,\n    difference,\n    path,\n    assocPath,\n    dissocPath,\n    cloneDeep,\n    mergeDeep,\n    preserveUndefined,\n    configValidator,\n    singleTransformValidator,\n    transformsValidator,\n    getRootKeysGroup,\n} from './utils';\n\nimport { PLACEHOLDER_UNDEFINED, PACKAGE_NAME } from './constants';\nimport { TObject, ConfigType, RootKeysGroup, PersistConfig, GetPersistConfigArgs } from './types';\n\ntype TransformConfig = {\n    whitelist?: string[];\n    blacklist?: string[];\n};\n\n// Taken directly from redux-persist to avoid peerDependency with extended output by \"deepPersistKey\" property\nconst createTransform = function (inbound: Function, outbound: Function, config: TransformConfig = {}): any {\n    const whitelist = config.whitelist || null;\n    const blacklist = config.blacklist || null;\n\n    function whitelistBlacklistCheck(key: string) {\n        if (whitelist && whitelist.indexOf(key) === -1) return true;\n        if (blacklist && blacklist.indexOf(key) !== -1) return true;\n        return false;\n    }\n\n    return {\n        in: (state: Record<string, unknown>, key: string, fullState: Record<string, unknown>) =>\n            !whitelistBlacklistCheck(key) && inbound ? inbound(state, key, fullState) : state,\n        out: (state: Record<string, unknown>, key: string, fullState: Record<string, unknown>) =>\n            !whitelistBlacklistCheck(key) && outbound ? outbound(state, key, fullState) : state,\n        deepPersistKey: whitelist && whitelist[0],\n    };\n};\n\n// Based on redux-persist/lib/stateReconciler/autoMergeLevel2 but with deep merging\nexport const autoMergeDeep = <S>(\n    inboundState: any,\n    originalState: S,\n    reducedState: S,\n    { debug, whitelist, blacklist, transforms }: PersistConfig<S>,\n): S => {\n    if (whitelist || blacklist) {\n        throw new Error(\n            'State reconciler autoMergeDeep uses custom transforms instead of old whitelist or blacklist config properties. Please use createWhitelist or createBlacklist transforms.',\n        );\n    }\n\n    // check transforms for duplicates to avoid createWhitelist / blacklist for the same root reducer key more than once\n    transformsValidator(transforms);\n\n    const newState = cloneDeep(reducedState);\n    let toRehydrateState = inboundState;\n\n    // only rehydrate if inboundState exists and is an object\n    if (toRehydrateState && isObjectLike(toRehydrateState)) {\n        // if any of sub state was modified by your reducer on redux-persist rehydrate action\n        // then modified values has priority over the inbound state coming from storage\n        const diff = difference(originalState, reducedState);\n\n        if (!isEmpty(diff)) {\n            toRehydrateState = mergeDeep(inboundState, diff, { preserveUndefined: true });\n            if (debug) {\n                console.log(\n                    `${PACKAGE_NAME}/autoMergeDeep: sub state of your state was modified by reducer during rehydration. Values from reducer will be kept: ${JSON.stringify(\n                        diff,\n                    )}`,\n                );\n            }\n        }\n\n        Object.keys(toRehydrateState).forEach((key) => {\n            // ignore _persist data\n            if (key === '_persist') {\n                return;\n            }\n\n            if (isObjectLike(newState[key])) {\n                newState[key] = mergeDeep(newState[key], toRehydrateState[key]);\n                return;\n            }\n\n            // otherwise hard set\n            newState[key] = toRehydrateState[key];\n        });\n    }\n\n    if (debug && toRehydrateState && isObjectLike(toRehydrateState)) {\n        console.log(`${PACKAGE_NAME}/autoMergeDeep: rehydrated keys ${JSON.stringify(toRehydrateState)}`);\n    }\n\n    return newState;\n};\n\n// Transform returns a piece of inboundState based on passed whitelist paths\nexport const createWhitelist = (key: string, whitelist?: string[]) => {\n    singleTransformValidator(whitelist, key, ConfigType.WHITELIST);\n\n    return createTransform(\n        // transform state on its way to being serialized and persisted.\n        (inboundState: TObject) => {\n            if (!whitelist || !whitelist.length) {\n                return inboundState;\n            }\n\n            let inboundToPersist: TObject | null = null;\n            let value;\n\n            whitelist.forEach((statePath) => {\n                const pathArray = statePath.split('.');\n                value = path(inboundState, pathArray);\n                if (typeof value === 'undefined' && isIntegerString(pathArray[pathArray.length - 1])) {\n                    value = PLACEHOLDER_UNDEFINED;\n                }\n\n                const assocResult = assocPath(pathArray, value);\n                const initial = isArray(assocResult) ? [] : {};\n\n                inboundToPersist = mergeDeep(!inboundToPersist ? initial : inboundToPersist, assocResult, {\n                    preservePlaceholder: true,\n                });\n            });\n\n            return inboundToPersist || inboundState;\n        },\n        // transform state being rehydrated\n        (outboundState: TObject) => {\n            return preserveUndefined(outboundState, whitelist, ConfigType.WHITELIST);\n        },\n        // define which reducers this transform gets called for\n        {\n            whitelist: [key],\n        },\n    );\n};\n\n// Transform returns a piece of inboundState based on passed blacklist paths\nexport const createBlacklist = (key: string, blacklist?: string[]) => {\n    singleTransformValidator(blacklist, key, ConfigType.BLACKLIST);\n    return createTransform(\n        // transform state on its way to being serialized and persisted.\n        (inboundState: TObject) => {\n            if (!blacklist || !blacklist.length) {\n                return;\n            }\n\n            // need to preserve @@placeholder/undefined if undefined value of an array isn't mentioned on the blacklist\n            const inboundToPersist = preserveUndefined(inboundState, blacklist, ConfigType.BLACKLIST, true);\n\n            const paths = blacklist.map((statePath) => statePath.split('.'));\n\n            return paths.reduce((inboundToPersist, pathArray) => {\n                return dissocPath(inboundToPersist, pathArray);\n            }, inboundToPersist);\n        },\n        // transform state being rehydrated\n        (outboundState: TObject) => {\n            return preserveUndefined(outboundState, blacklist, ConfigType.BLACKLIST);\n        },\n        // define which reducers this transform gets called for\n        {\n            whitelist: [key],\n        },\n    );\n};\n\n// Helper methods to create a correct redux-persist config\nexport const getTransforms = function (type: ConfigType, list: RootKeysGroup[]) {\n    return list.map((rootObject) => {\n        const key = Object.keys(rootObject)[0];\n        const paths = rootObject[key];\n        return type === ConfigType.WHITELIST ? createWhitelist(key, paths) : createBlacklist(key, paths);\n    });\n};\n\nexport const getPersistConfig = <S>({\n    key,\n    whitelist,\n    blacklist,\n    storage,\n    transforms,\n    rootReducer,\n    ...rest\n}: GetPersistConfigArgs<S>): PersistConfig<S> => {\n    configValidator({ whitelist, blacklist });\n\n    const whitelistByRootKeys = getRootKeysGroup(whitelist);\n    const blacklistByRootKeys = getRootKeysGroup(blacklist);\n\n    const allRootKeys = Object.keys(rootReducer(undefined, { type: '' }));\n    const whitelistRootKeys = whitelistByRootKeys.map((rootObject) => Object.keys(rootObject)[0]);\n    const blacklistRootKeys = blacklistByRootKeys.map((rootObject) => Object.keys(rootObject)[0]);\n\n    // in case a whitelist or blacklist is specified the other keys shouldn't be included in a storage\n    const keysToExclude = allRootKeys.filter(\n        (k: string) => whitelistRootKeys.indexOf(k) === -1 && blacklistRootKeys.indexOf(k) === -1,\n    );\n\n    const whitelistTransforms = getTransforms(ConfigType.WHITELIST, whitelistByRootKeys);\n    const blacklistTransforms = getTransforms(ConfigType.BLACKLIST, blacklistByRootKeys);\n\n    // excluding any other keys by creating blacklist transforms for them\n    const excludedKeysTransforms = isArray(whitelist) ? keysToExclude.map((key) => createBlacklist(key)) : [];\n\n    return {\n        ...rest,\n        key,\n        storage,\n        transforms: [\n            ...whitelistTransforms,\n            ...blacklistTransforms,\n            ...excludedKeysTransforms,\n            // all the other transforms like user's ones will be added at the end\n            ...(transforms ? transforms : []),\n        ],\n        stateReconciler: autoMergeDeep,\n    };\n};\n"]},"metadata":{},"sourceType":"script"}