{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getRootKeysGroup = exports.throwError = exports.configValidator = exports.transformsValidator = exports.singleTransformValidator = exports.findDuplicatesAndSubsets = exports.unique = exports.preserveUndefined = exports.mergeDeep = exports.dissocPath = exports.assocPath = exports.path = exports.difference = exports.cloneDeep = exports._cloneDeep = exports.getCircularPath = exports.isEmpty = exports.isDate = exports.isString = exports.isIntegerString = exports.isPlainObject = exports.isArray = exports.isLength = exports.isObjectLike = void 0;\n\nconst constants_1 = require(\"../constants\");\n\nconst types_1 = require(\"../types\");\n\nconst isObjectLike = function (value) {\n  return typeof value === 'object' && value !== null;\n};\n\nexports.isObjectLike = isObjectLike;\n\nconst isLength = function (value) {\n  return typeof value === 'number' && value > -1 && value % 1 == 0 && value <= Number.MAX_SAFE_INTEGER;\n};\n\nexports.isLength = isLength;\n\nexports.isArray = Array.isArray || function (value) {\n  return (0, exports.isLength)(value && value.length) && Object.prototype.toString.call(value) === '[object Array]';\n};\n\nconst isPlainObject = function (item) {\n  return !!item && typeof item === 'object' && !(0, exports.isArray)(item);\n};\n\nexports.isPlainObject = isPlainObject;\n\nconst isIntegerString = function (x) {\n  return String(~~x) === x && Number(x) >= 0;\n};\n\nexports.isIntegerString = isIntegerString;\n\nconst isString = function (x) {\n  return Object.prototype.toString.call(x) === '[object String]';\n};\n\nexports.isString = isString;\n\nconst isDate = function (x) {\n  return Object.prototype.toString.call(x) === '[object Date]';\n};\n\nexports.isDate = isDate;\n\nconst isEmpty = function (obj) {\n  return Object.keys(obj).length === 0;\n};\n\nexports.isEmpty = isEmpty;\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nconst getCircularPath = function (obj, path, seen) {\n  seen || (seen = new Set([obj]));\n  path || (path = '');\n\n  for (const key in obj) {\n    const currentPath = path ? `${path}.${key}` : key;\n    const value = obj[key];\n\n    if ((0, exports.isObjectLike)(value)) {\n      if (seen.has(value)) {\n        return `${path}.${key}:<Circular>`;\n      } else {\n        seen.add(value);\n        return (0, exports.getCircularPath)(value, currentPath, seen);\n      }\n    }\n  }\n\n  return null;\n};\n\nexports.getCircularPath = getCircularPath;\n\nconst _cloneDeep = function (obj) {\n  if (!(0, exports.isObjectLike)(obj)) {\n    return obj;\n  }\n\n  if ((0, exports.isDate)(obj)) {\n    return new Date(+obj);\n  }\n\n  const newObj = (0, exports.isArray)(obj) ? [] : {};\n\n  for (const key in obj) {\n    const value = obj[key];\n    newObj[key] = (0, exports._cloneDeep)(value);\n  }\n\n  return newObj;\n};\n\nexports._cloneDeep = _cloneDeep;\n\nconst cloneDeep = function (obj) {\n  const path = (0, exports.getCircularPath)(obj);\n\n  if (path) {\n    throw new Error(`${constants_1.PACKAGE_NAME}: circular dependency detected under the path '${path}' of object you're trying to persist: ${obj}`);\n  }\n\n  return (0, exports._cloneDeep)(obj);\n};\n\nexports.cloneDeep = cloneDeep;\n\nconst difference = function (base, newValue) {\n  if (base === newValue) {\n    return {};\n  }\n\n  if (!(0, exports.isObjectLike)(base) || !(0, exports.isObjectLike)(newValue)) {\n    return newValue;\n  }\n\n  const l = (0, exports.cloneDeep)(base);\n  const r = (0, exports.cloneDeep)(newValue);\n  const deletedValues = Object.keys(l).reduce((acc, key) => {\n    if (hasOwnProperty.call(r, key)) {\n      return acc;\n    }\n\n    acc[key] = undefined;\n    return acc;\n  }, {});\n\n  if ((0, exports.isDate)(l) || (0, exports.isDate)(r)) {\n    if (l.valueOf() === r.valueOf()) {\n      return {};\n    }\n\n    return r;\n  }\n\n  const result = Object.keys(r).reduce((acc, key) => {\n    if (!hasOwnProperty.call(l, key)) {\n      acc[key] = r[key];\n      return acc;\n    }\n\n    const diff = (0, exports.difference)(l[key], r[key]);\n\n    if ((0, exports.isObjectLike)(diff) && (0, exports.isEmpty)(diff) && !(0, exports.isDate)(diff)) {\n      if ((0, exports.isArray)(l) && !(0, exports.isArray)(r) || !(0, exports.isArray)(l) && (0, exports.isArray)(r)) {\n        return r;\n      }\n\n      return acc;\n    }\n\n    acc[key] = diff;\n    return acc;\n  }, deletedValues);\n  delete result._persist;\n  return result;\n};\n\nexports.difference = difference;\n\nconst path = function (obj, pathArray) {\n  return pathArray.reduce((acc, curr) => {\n    if (acc) {\n      const parsedCurr = parseInt(curr, 10);\n      const index = (0, exports.isIntegerString)(curr) && parsedCurr < 0 ? acc.length + parsedCurr : curr;\n      return (0, exports.isString)(acc) ? acc.charAt(index) : acc[index];\n    }\n  }, obj);\n};\n\nexports.path = path;\n\nconst assocPath = function (path, value) {\n  const pathArray = [...path].reverse();\n  const result = pathArray.reduce((acc, curr, index) => {\n    const placeholder = (0, exports.isIntegerString)(curr) ? [] : {};\n    placeholder[curr] = index === 0 ? value : acc;\n    return placeholder;\n  }, {});\n  return result;\n};\n\nexports.assocPath = assocPath;\n\nconst dissocPath = function (obj, pathArray) {\n  const clone = (0, exports.cloneDeep)(obj);\n  pathArray.reduce((acc, curr, index) => {\n    if (index === pathArray.length - 1 && acc) {\n      if ((0, exports.isObjectLike)(acc)) {\n        delete acc[curr];\n      }\n    }\n\n    return acc && acc[curr];\n  }, clone);\n  return clone;\n};\n\nexports.dissocPath = dissocPath;\n\nconst _mergeDeep = function (options, target) {\n  for (var _len = arguments.length, sources = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    sources[_key - 2] = arguments[_key];\n  }\n\n  if (!sources || !sources.length) {\n    return target;\n  }\n\n  const source = sources.shift();\n  const {\n    preservePlaceholder,\n    preserveUndefined\n  } = options;\n\n  if ((0, exports.isObjectLike)(target) && (0, exports.isObjectLike)(source)) {\n    for (const key in source) {\n      if ((0, exports.isObjectLike)(source[key]) && (0, exports.isObjectLike)(target[key])) {\n        if (!target[key]) {\n          target[key] = {};\n        }\n\n        _mergeDeep(options, target[key], source[key]);\n      } else {\n        if ((0, exports.isArray)(target)) {\n          let sourceValue = source[key];\n          const placeholder = preservePlaceholder ? constants_1.PLACEHOLDER_UNDEFINED : undefined;\n\n          if (!preserveUndefined) {\n            sourceValue = typeof sourceValue !== 'undefined' ? sourceValue : target[parseInt(key, 10)];\n          }\n\n          sourceValue = sourceValue !== constants_1.PLACEHOLDER_UNDEFINED ? sourceValue : placeholder;\n          target[parseInt(key, 10)] = sourceValue;\n        } else {\n          const value = source[key] !== constants_1.PLACEHOLDER_UNDEFINED ? source[key] : undefined;\n          target[key] = value;\n        }\n      }\n    }\n  }\n\n  return _mergeDeep(options, target, ...sources);\n};\n\nconst mergeDeep = function (target, source, options) {\n  return _mergeDeep({\n    preservePlaceholder: options === null || options === void 0 ? void 0 : options.preservePlaceholder,\n    preserveUndefined: options === null || options === void 0 ? void 0 : options.preserveUndefined\n  }, (0, exports.cloneDeep)(target), (0, exports.cloneDeep)(source));\n};\n\nexports.mergeDeep = mergeDeep;\n\nconst _preserveUndefined = function (obj) {\n  let pathsArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let type = arguments.length > 2 ? arguments[2] : undefined;\n  let prevPath = arguments.length > 3 ? arguments[3] : undefined;\n  let preserveAsPlaceholder = arguments.length > 4 ? arguments[4] : undefined;\n\n  if (!(0, exports.isObjectLike)(obj)) {\n    return obj;\n  }\n\n  for (const key in obj) {\n    const value = obj[key];\n    const belongsToArray = (0, exports.isArray)(obj);\n    const pathString = prevPath ? prevPath + '.' + key : key;\n\n    if (value === null && (type === types_1.ConfigType.WHITELIST && pathsArray.indexOf(pathString) === -1 || type === types_1.ConfigType.BLACKLIST && pathsArray.indexOf(pathString) !== -1) && belongsToArray) {\n      obj[parseInt(key, 10)] = undefined;\n    }\n\n    if (value === undefined && preserveAsPlaceholder && type === types_1.ConfigType.BLACKLIST && pathsArray.indexOf(pathString) === -1 && belongsToArray) {\n      obj[parseInt(key, 10)] = constants_1.PLACEHOLDER_UNDEFINED;\n    }\n\n    _preserveUndefined(value, pathsArray, type, pathString, preserveAsPlaceholder);\n  }\n};\n\nconst preserveUndefined = function (outboundState, pathsArray, type, preserveAsPlaceholder) {\n  const clone = (0, exports.cloneDeep)(outboundState);\n\n  _preserveUndefined(clone, pathsArray, type, '', preserveAsPlaceholder);\n\n  return clone;\n};\n\nexports.preserveUndefined = preserveUndefined;\n\nconst unique = function (value, index, self) {\n  return self.indexOf(value) === index;\n};\n\nexports.unique = unique;\n\nconst findDuplicatesAndSubsets = function (list) {\n  return list.reduce((entities, path) => {\n    const filteredDuplicates = list.filter(inner => inner === path);\n    const filteredSubsets = list.filter(inner => {\n      return (path + '.').indexOf(inner + '.') === 0;\n    });\n    const {\n      duplicates,\n      subsets\n    } = entities;\n    const foundDuplicates = filteredDuplicates.length > 1 && duplicates.indexOf(path) === -1;\n    const foundSubsets = filteredSubsets.length > 1;\n    return {\n      duplicates: [...duplicates, ...(foundDuplicates ? filteredDuplicates : [])],\n      subsets: [...subsets, ...(foundSubsets ? filteredSubsets : [])].filter(exports.unique).sort()\n    };\n  }, {\n    duplicates: [],\n    subsets: []\n  });\n};\n\nexports.findDuplicatesAndSubsets = findDuplicatesAndSubsets;\n\nconst singleTransformValidator = function (config, name, type) {\n  const listType = type === types_1.ConfigType.WHITELIST ? 'whitelist' : 'blacklist';\n  const commonErrorMsg1 = `${constants_1.PACKAGE_NAME}: incorrect ${listType} configuration.`;\n  const commonErrorMsg2 = `Check your create${type === types_1.ConfigType.WHITELIST ? 'White' : 'Black'}list arguments.\\n\\n`;\n\n  if (!(0, exports.isString)(name) || name.length < 1) {\n    throw new Error(`${commonErrorMsg1} Name (key) of reducer is required. ${commonErrorMsg2}`);\n  }\n\n  if (!config || !config.length) {\n    return;\n  }\n\n  const {\n    duplicates,\n    subsets\n  } = (0, exports.findDuplicatesAndSubsets)(config);\n\n  if (duplicates.length > 1) {\n    throw new Error(`${commonErrorMsg1} Duplicated paths.\\n\\n ${JSON.stringify(duplicates)}\\n\\n ${commonErrorMsg2}`);\n  }\n\n  if (subsets.length > 1) {\n    throw new Error(`${commonErrorMsg1} You are trying to persist an entire property and also some of its subset.\\n\\n${JSON.stringify(subsets)}\\n\\n ${commonErrorMsg2}`);\n  }\n};\n\nexports.singleTransformValidator = singleTransformValidator;\n\nconst transformsValidator = function (transforms) {\n  if (!(0, exports.isArray)(transforms)) {\n    return;\n  }\n\n  const keys = (transforms === null || transforms === void 0 ? void 0 : transforms.map(t => t.deepPersistKey).filter(k => k)) || [];\n\n  if (keys.length) {\n    const duplicates = keys.filter((key, index) => keys.indexOf(key) !== index);\n\n    if (duplicates.length) {\n      throw new Error(`${constants_1.PACKAGE_NAME}: found duplicated keys in transforms creators. You can createWhitelist or createBlacklist for a specific root reducer key only once. Duplicated keys among createWhitelist and createBlacklist transforms are not allowed.\\n\\n Duplicates: ${JSON.stringify(duplicates)}`);\n    }\n  }\n};\n\nexports.transformsValidator = transformsValidator;\n\nconst configValidator = function (_ref) {\n  let {\n    whitelist,\n    blacklist\n  } = _ref;\n\n  if (whitelist && whitelist.length && blacklist && blacklist.length) {\n    throw new Error(`${constants_1.PACKAGE_NAME}: you should not define a whitelist and blacklist in parallel. It is allowed to use only one of these lists per config.`);\n  }\n\n  if (whitelist) {\n    const {\n      duplicates,\n      subsets\n    } = (0, exports.findDuplicatesAndSubsets)(whitelist);\n    (0, exports.throwError)({\n      duplicates,\n      subsets\n    }, 'whitelist');\n  }\n\n  if (blacklist) {\n    const {\n      duplicates,\n      subsets\n    } = (0, exports.findDuplicatesAndSubsets)(blacklist);\n    (0, exports.throwError)({\n      duplicates,\n      subsets\n    }, 'blacklist');\n  }\n};\n\nexports.configValidator = configValidator;\n\nconst throwError = function (_ref2, listType) {\n  let {\n    duplicates,\n    subsets\n  } = _ref2;\n\n  if (duplicates.length) {\n    throw new Error(`${constants_1.PACKAGE_NAME}: duplicates of paths found in your ${listType}.\\n\\n ${JSON.stringify(duplicates)}`);\n  }\n\n  if (subsets.length) {\n    throw new Error(`${constants_1.PACKAGE_NAME}: subsets of some parent keys found in your ${listType}. You must decide if you want to persist an entire path or its specific subset.\\n\\n ${JSON.stringify(subsets)}`);\n  }\n};\n\nexports.throwError = throwError;\n\nconst getRootKeysGroup = function (list) {\n  if (!(0, exports.isArray)(list)) {\n    return [];\n  }\n\n  return list.filter(exports.unique).reduce((acc, curr) => {\n    const pathArray = curr.split('.');\n    const rootKey = pathArray[0];\n    const path = pathArray.slice(1).join('.') || undefined;\n    const existingElement = acc.filter(entity => {\n      const key = Object.keys(entity)[0];\n      return key === rootKey;\n    })[0];\n    const existingValue = existingElement ? Object.values(existingElement)[0] : undefined;\n\n    if (!existingElement) {\n      acc.push({\n        [rootKey]: path ? [path] : undefined\n      });\n    }\n\n    if (existingElement && !existingValue && path) {\n      existingElement[rootKey] = [path];\n    }\n\n    if (existingElement && existingValue && path) {\n      existingValue.push(path);\n    }\n\n    return acc;\n  }, []);\n};\n\nexports.getRootKeysGroup = getRootKeysGroup;","map":{"version":3,"mappings":"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","names":["isObjectLike","value","exports","isLength","Number","MAX_SAFE_INTEGER","Array","isArray","length","Object","prototype","toString","call","isPlainObject","item","isIntegerString","x","String","isString","isDate","isEmpty","obj","keys","hasOwnProperty","getCircularPath","path","seen","Set","key","currentPath","has","add","_cloneDeep","Date","newObj","cloneDeep","Error","constants_1","difference","base","newValue","l","r","deletedValues","reduce","acc","undefined","valueOf","result","diff","_persist","pathArray","curr","parsedCurr","parseInt","index","charAt","assocPath","reverse","placeholder","dissocPath","clone","_mergeDeep","options","target","sources","source","shift","preservePlaceholder","preserveUndefined","sourceValue","mergeDeep","_preserveUndefined","pathsArray","type","prevPath","preserveAsPlaceholder","belongsToArray","pathString","types_1","WHITELIST","indexOf","BLACKLIST","outboundState","unique","self","findDuplicatesAndSubsets","list","entities","filteredDuplicates","filter","inner","filteredSubsets","duplicates","subsets","foundDuplicates","foundSubsets","sort","singleTransformValidator","config","name","listType","commonErrorMsg1","commonErrorMsg2","JSON","stringify","transformsValidator","transforms","map","t","deepPersistKey","k","configValidator","whitelist","blacklist","throwError","getRootKeysGroup","split","rootKey","slice","join","existingElement","entity","existingValue","values","push"],"sources":["/Users/sergiyrybin/Documents/IT/goit-react-hw-07-phonebook/node_modules/redux-deep-persist/src/utils/index.ts"],"sourcesContent":["import { PACKAGE_NAME, PLACEHOLDER_UNDEFINED } from '../constants';\nimport { TObject, ConfigType, RootKeysGroup } from '../types';\n\nexport const isObjectLike = function (value: any) {\n    return typeof value === 'object' && value !== null;\n};\n\nexport const isLength = function (value: any) {\n    return typeof value === 'number' && value > -1 && value % 1 == 0 && value <= Number.MAX_SAFE_INTEGER;\n};\n\nexport const isArray =\n    Array.isArray ||\n    function (value: any) {\n        return isLength(value && value.length) && Object.prototype.toString.call(value) === '[object Array]';\n    };\n\nexport const isPlainObject = function (item: any) {\n    return !!item && typeof item === 'object' && !isArray(item);\n};\n\nexport const isIntegerString = function (x: any) {\n    return String(~~x) === x && Number(x) >= 0;\n};\n\nexport const isString = function (x: any) {\n    return Object.prototype.toString.call(x) === '[object String]';\n};\n\nexport const isDate = function (x: any) {\n    return Object.prototype.toString.call(x) === '[object Date]';\n};\n\nexport const isEmpty = function (obj: TObject) {\n    return Object.keys(obj).length === 0;\n};\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexport const getCircularPath = function (obj: TObject, path?: string, seen?: Set<any>): string | null {\n    seen || (seen = new Set([obj]));\n    path || (path = '');\n\n    for (const key in obj) {\n        const currentPath = path ? `${path}.${key}` : key;\n        const value = obj[key];\n        if (isObjectLike(value)) {\n            if (seen.has(value)) {\n                return `${path}.${key}:<Circular>`;\n            } else {\n                seen.add(value);\n                return getCircularPath(value, currentPath, seen);\n            }\n        }\n    }\n\n    return null;\n};\n\nexport const _cloneDeep = function (obj: TObject) {\n    if (!isObjectLike(obj)) {\n        return obj;\n    }\n\n    if (isDate(obj)) {\n        return new Date(+obj);\n    }\n\n    const newObj: TObject = isArray(obj) ? [] : {};\n    for (const key in obj) {\n        const value = obj[key];\n        newObj[key] = _cloneDeep(value);\n    }\n    return newObj;\n};\n\nexport const cloneDeep = function (obj: TObject) {\n    const path = getCircularPath(obj);\n    if (path) {\n        throw new Error(\n            `${PACKAGE_NAME}: circular dependency detected under the path '${path}' of object you're trying to persist: ${obj}`,\n        );\n    }\n    return _cloneDeep(obj);\n};\n\nexport const difference = function (base: any, newValue: any): TObject {\n    if (base === newValue) {\n        return {};\n    }\n\n    if (!isObjectLike(base) || !isObjectLike(newValue)) {\n        return newValue;\n    }\n\n    const l = cloneDeep(base);\n    const r = cloneDeep(newValue);\n\n    // deleted values\n    const deletedValues = Object.keys(l).reduce((acc: TObject, key) => {\n        if (hasOwnProperty.call(r, key)) {\n            return acc;\n        }\n        acc[key] = undefined;\n        return acc;\n    }, {});\n\n    // date values\n    if (isDate(l) || isDate(r)) {\n        if (l.valueOf() === r.valueOf()) {\n            return {};\n        }\n        return r;\n    }\n\n    // added values\n    const result: TObject = Object.keys(r).reduce((acc: TObject, key) => {\n        if (!hasOwnProperty.call(l, key)) {\n            acc[key] = r[key];\n            return acc;\n        }\n\n        const diff = difference(l[key], r[key]);\n\n        if (isObjectLike(diff) && isEmpty(diff) && !isDate(diff)) {\n            // if r or l are array vs plainObject we need to return a new value\n            if ((isArray(l) && !isArray(r)) || (!isArray(l) && isArray(r))) {\n                return r;\n            }\n            return acc; // no difference\n        }\n\n        acc[key] = diff; // new value\n        return acc;\n    }, deletedValues);\n\n    delete result._persist;\n    return result;\n};\n\nexport const path = function (obj: TObject, pathArray: string[]) {\n    return pathArray.reduce((acc, curr) => {\n        if (acc) {\n            const parsedCurr = parseInt(curr, 10);\n            const index = isIntegerString(curr) && parsedCurr < 0 ? acc.length + parsedCurr : curr;\n            return isString(acc) ? acc.charAt(index) : acc[index];\n        }\n    }, obj);\n};\n\nexport const assocPath = function (path: string[], value: any) {\n    const pathArray = [...path].reverse();\n    const result = pathArray.reduce((acc: TObject, curr: string, index: number) => {\n        const placeholder: TObject = isIntegerString(curr) ? [] : {};\n        placeholder[curr] = index === 0 ? value : acc;\n        return placeholder;\n    }, {});\n    return result;\n};\n\nexport const dissocPath = function (obj: TObject, pathArray: string[]) {\n    const clone = cloneDeep(obj);\n    pathArray.reduce((acc, curr, index) => {\n        if (index === pathArray.length - 1 && acc) {\n            if (isObjectLike(acc)) {\n                delete acc[curr];\n            }\n        }\n        return acc && acc[curr];\n    }, clone);\n    return clone;\n};\n\nconst _mergeDeep = function (\n    options: {\n        preservePlaceholder?: boolean;\n        preserveUndefined?: boolean;\n    },\n    target: TObject,\n    ...sources: TObject[]\n): TObject {\n    if (!sources || !sources.length) {\n        return target;\n    }\n    const source = sources.shift();\n    const { preservePlaceholder, preserveUndefined } = options;\n\n    if (isObjectLike(target) && isObjectLike(source)) {\n        for (const key in source) {\n            if (isObjectLike(source[key]) && isObjectLike(target[key])) {\n                if (!target[key]) {\n                    target[key] = {};\n                }\n                _mergeDeep(options, target[key], source[key]);\n            } else {\n                if (isArray(target)) {\n                    // If !preserveUndefined then undefined will not overwrite the initial state of an array but null or anything else will do\n                    // @@placeholder/undefined will be replaced with undefined if preservePlaceholder is false\n                    let sourceValue = source[key];\n                    const placeholder = preservePlaceholder ? PLACEHOLDER_UNDEFINED : undefined;\n\n                    if (!preserveUndefined) {\n                        sourceValue = typeof sourceValue !== 'undefined' ? sourceValue : target[parseInt(key, 10)];\n                    }\n\n                    sourceValue = sourceValue !== PLACEHOLDER_UNDEFINED ? sourceValue : placeholder;\n                    target[parseInt(key, 10)] = sourceValue;\n                } else {\n                    const value = source[key] !== PLACEHOLDER_UNDEFINED ? source[key] : undefined;\n                    target[key] = value;\n                }\n            }\n        }\n    }\n    return _mergeDeep(options, target, ...sources);\n};\n\nexport const mergeDeep = function (\n    target: TObject,\n    source: TObject,\n    options?: {\n        preservePlaceholder?: boolean;\n        preserveUndefined?: boolean;\n    },\n) {\n    return _mergeDeep(\n        {\n            preservePlaceholder: options?.preservePlaceholder,\n            preserveUndefined: options?.preserveUndefined,\n        },\n        cloneDeep(target),\n        cloneDeep(source),\n    );\n};\n\n/**\n * It's not possible to keep an undefined array value in storage because it is stringified.\n * Any undefined array value will be converted to null.\n * If some nullish values will come back from storage, this method is to distinguish if it was meant to\n * be persisted based on the persist configuration.\n * EXAMPLE: if we want to persist only second index of an array, we will send [undefined, undefined, 'something']\n * to storage but stringified value will be [null, null, 'something'].\n * When such array will come back from storage, how could we know these nullish values wren't intended\n * to be persisted, we could either set them intentionally.\n * In such case we wouldn't know if a \"null\" which came back from a storage should overwrite currently reduced value or not.\n * That's why we change it to undefined if it wasn't meant to be persisted or we'll keep it as a null if we want it.\n * The function mergeDeep will overwrite reduced state with a null but will keep it as it is if an undefined will come.\n * The only way to keep real undefined values in an array persisted in a storage is to use @@placeholder/undefined value\n * which will be replaced with a real undefined while merging process of reduced state with storage outbound state.\n */\nconst _preserveUndefined = function (\n    obj: TObject,\n    pathsArray: string[] = [],\n    type: ConfigType,\n    prevPath: string,\n    preserveAsPlaceholder?: boolean,\n) {\n    if (!isObjectLike(obj)) {\n        return obj;\n    }\n\n    for (const key in obj) {\n        const value = obj[key];\n        const belongsToArray = isArray(obj);\n        const pathString = prevPath ? prevPath + '.' + key : key;\n\n        if (\n            value === null &&\n            ((type === ConfigType.WHITELIST && pathsArray.indexOf(pathString) === -1) ||\n                (type === ConfigType.BLACKLIST && pathsArray.indexOf(pathString) !== -1)) &&\n            belongsToArray\n        ) {\n            obj[parseInt(key, 10)] = undefined;\n        }\n\n        if (\n            value === undefined &&\n            preserveAsPlaceholder &&\n            type === ConfigType.BLACKLIST &&\n            pathsArray.indexOf(pathString) === -1 &&\n            belongsToArray\n        ) {\n            obj[parseInt(key, 10)] = PLACEHOLDER_UNDEFINED;\n        }\n\n        _preserveUndefined(value, pathsArray, type, pathString, preserveAsPlaceholder);\n    }\n};\n\nexport const preserveUndefined = function (\n    outboundState: TObject,\n    pathsArray: string[] | undefined,\n    type: ConfigType,\n    preserveAsPlaceholder?: boolean,\n) {\n    const clone = cloneDeep(outboundState);\n    _preserveUndefined(clone, pathsArray, type, '', preserveAsPlaceholder);\n    return clone;\n};\n\nexport const unique = function (value: string, index: number, self: string[]) {\n    return self.indexOf(value) === index;\n};\n\nexport const findDuplicatesAndSubsets = function (list: string[]): { duplicates: string[]; subsets: string[] } {\n    return list.reduce<{\n        duplicates: string[];\n        subsets: string[];\n    }>(\n        (entities, path) => {\n            const filteredDuplicates = list.filter((inner) => inner === path);\n            const filteredSubsets = list.filter((inner) => {\n                return (path + '.').indexOf(inner + '.') === 0;\n            });\n            const { duplicates, subsets } = entities;\n            const foundDuplicates = filteredDuplicates.length > 1 && duplicates.indexOf(path) === -1;\n            const foundSubsets = filteredSubsets.length > 1;\n            return {\n                duplicates: [...duplicates, ...(foundDuplicates ? filteredDuplicates : [])],\n                subsets: [...subsets, ...(foundSubsets ? filteredSubsets : [])].filter(unique).sort(),\n            };\n        },\n        {\n            duplicates: [],\n            subsets: [],\n        },\n    );\n};\n\nexport const singleTransformValidator = function (config: string[] | undefined, name: string, type: ConfigType) {\n    const listType = type === ConfigType.WHITELIST ? 'whitelist' : 'blacklist';\n    const commonErrorMsg1 = `${PACKAGE_NAME}: incorrect ${listType} configuration.`;\n    const commonErrorMsg2 = `Check your create${type === ConfigType.WHITELIST ? 'White' : 'Black'}list arguments.\\n\\n`;\n\n    if (!isString(name) || name.length < 1) {\n        throw new Error(`${commonErrorMsg1} Name (key) of reducer is required. ${commonErrorMsg2}`);\n    }\n\n    if (!config || !config.length) {\n        return;\n    }\n\n    const { duplicates, subsets } = findDuplicatesAndSubsets(config);\n\n    if (duplicates.length > 1) {\n        throw new Error(\n            `${commonErrorMsg1} Duplicated paths.\\n\\n ${JSON.stringify(duplicates)}\\n\\n ${commonErrorMsg2}`,\n        );\n    }\n\n    if (subsets.length > 1) {\n        throw new Error(\n            `${commonErrorMsg1} You are trying to persist an entire property and also some of its subset.\\n\\n${JSON.stringify(\n                subsets,\n            )}\\n\\n ${commonErrorMsg2}`,\n        );\n    }\n};\n\nexport const transformsValidator = function (\n    transforms?: Array<{\n        deepPersistKey?: string;\n    }>,\n) {\n    if (!isArray(transforms)) {\n        return;\n    }\n\n    const keys = transforms?.map((t) => t.deepPersistKey).filter((k) => k) || [];\n\n    if (keys.length) {\n        const duplicates = keys.filter((key, index) => keys.indexOf(key) !== index);\n\n        if (duplicates.length) {\n            throw new Error(\n                `${PACKAGE_NAME}: found duplicated keys in transforms creators. You can createWhitelist or createBlacklist for a specific root reducer key only once. Duplicated keys among createWhitelist and createBlacklist transforms are not allowed.\\n\\n Duplicates: ${JSON.stringify(\n                    duplicates,\n                )}`,\n            );\n        }\n    }\n};\n\nexport const configValidator = function ({ whitelist, blacklist }: { whitelist?: string[]; blacklist?: string[] }) {\n    // 1. Find duplicated root keys within whitelist and blacklist\n    if (whitelist && whitelist.length && blacklist && blacklist.length) {\n        throw new Error(\n            `${PACKAGE_NAME}: you should not define a whitelist and blacklist in parallel. It is allowed to use only one of these lists per config.`,\n        );\n    }\n\n    // 2.\n    // - find duplicated root keys in whitelist or blacklist\n    // - find subsets despite an entire parent key was meant to be persisted\n    if (whitelist) {\n        const { duplicates, subsets } = findDuplicatesAndSubsets(whitelist);\n        throwError({ duplicates, subsets }, 'whitelist');\n    }\n\n    if (blacklist) {\n        const { duplicates, subsets } = findDuplicatesAndSubsets(blacklist);\n        throwError({ duplicates, subsets }, 'blacklist');\n    }\n};\n\nexport const throwError = function (\n    { duplicates, subsets }: { duplicates: string[]; subsets: string[] },\n    listType: string,\n) {\n    if (duplicates.length) {\n        throw new Error(\n            `${PACKAGE_NAME}: duplicates of paths found in your ${listType}.\\n\\n ${JSON.stringify(duplicates)}`,\n        );\n    }\n\n    if (subsets.length) {\n        throw new Error(\n            `${PACKAGE_NAME}: subsets of some parent keys found in your ${listType}. You must decide if you want to persist an entire path or its specific subset.\\n\\n ${JSON.stringify(\n                subsets,\n            )}`,\n        );\n    }\n};\n\nexport const getRootKeysGroup = function (list?: string[]) {\n    if (!isArray(list)) {\n        return [];\n    }\n\n    return list.filter(unique).reduce((acc: RootKeysGroup[], curr: string) => {\n        const pathArray = curr.split('.');\n        const rootKey = pathArray[0];\n        const path = pathArray.slice(1).join('.') || undefined;\n\n        const existingElement = acc.filter((entity) => {\n            const key = Object.keys(entity)[0];\n            return key === rootKey;\n        })[0];\n\n        const existingValue = existingElement ? Object.values(existingElement)[0] : undefined;\n\n        // if there is no element then create one\n        if (!existingElement) {\n            acc.push({\n                [rootKey]: path ? [path] : undefined,\n            });\n        }\n\n        // if there is an element but with undefined value and there is something to assign\n        if (existingElement && !existingValue && path) {\n            existingElement[rootKey] = [path];\n        }\n\n        // if there is an element and has a value and there is something to add - extend its value\n        if (existingElement && existingValue && path) {\n            existingValue.push(path);\n        }\n\n        // if there is an element with its value but there is nothing to assign then just return acc\n\n        return acc;\n    }, []);\n};\n"]},"metadata":{},"sourceType":"script"}